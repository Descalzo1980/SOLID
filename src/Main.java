public class Main {
    public static void main(String[] args) {
        Computer computer = new Computer("IBM", 80000);
        SaveInterface saveComputer = new SaveComputerToFile();
        SaveInterface saveComputerToFile = new SaveComputerToDB();
        saveComputer.save("некий путь" , computer);
        saveComputerToFile.save("некий путь" , computer);
    }
}

/*
* SOLID
*
* - принцип единственной ответственности
*
*Для каждого класса должно быть определено единственное назначение.
* Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы
* в этот класс и подчинены только этой задаче.
«программные сущности … должны быть открыты для расширения, но закрыты для модификации».
*  NO GOD class
   В классе Computer нарушение принципа. Не только представляет сам обьект, но и берет на себя роль сохранения и загрузки
   * данных. Если будем работать с БД, придется менять метод save, т.е. в целом менять класс.Класс должен выполянть строго
   * ту роль, которая ему отведена. Но момент тонкий)
   *
 * - принцип открытости закрытости
 * этот принцип предполагает что классы д.б. закрыты для модификации но открыты для расширения
 * класс SaveComputer нарушает этот принцип. Для соблюдения можем использовать полиморфизм и абстрактные классы
 * АК реализуем через интерфейсы Сделаем класс для разных методов.Добавляем новый функционал добавляя новые классы
 * и реализуя интерфейс с его методом
 *
 *
 * * - принцип подстановки Барбары Лисков
*«функции, которые используют базовый тип, должны иметь
* возможность использовать подтипы базового типа не зная об этом».


*
* - принцип разделения интерфейсов
*
*«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения».

* - принцип инверсии зависимости
*
*«Зависимость на Абстракциях. Нет зависимости на что-то конкретное».

* */
