public class Main {
    public static void main(String[] args) {
        Computer computer = new Computer("IBM", 5000);
        SaveInterface saveComputer = new SaveComputerToFile();
        SaveInterface saveComputerToFile = new SaveComputerToDB();
        saveComputer.save("некий путь" , computer);
        saveComputerToFile.save("некий путь" , computer);
        test();
        ModelForm modelForm = new ModelForm(1,55,"John Smith");
        WebFramework webFramework = new WebFramework();
        webFramework.save(modelForm);

        /*эти три класса нарушают принцип. поскольку завязаны напрямую с ModelForm*/
    }

    public static void test(){
        Computer computer = new Computer("IBM", 5000);
        Computer omenHP = new OmenHP("Omen HP", 5000);

        omenHP.setData("IBM");
        if(computer.name.compareTo(omenHP.name) == 0 && computer.memorySize == omenHP.memorySize){
            System.out.println("Тест окей");
        }else {
            System.out.println("Какая то ошибка");
        }

        /*Из за переопределения метода проверка не проходит*/
    }

}

/*
* SOLID
*
* - принцип единственной ответственности
*
*Для каждого класса должно быть определено единственное назначение.
* Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы
* в этот класс и подчинены только этой задаче.
«программные сущности … должны быть открыты для расширения, но закрыты для модификации».
*  NO GOD class
   В классе Computer нарушение принципа. Не только представляет сам обьект, но и берет на себя роль сохранения и загрузки
   * данных. Если будем работать с БД, придется менять метод save, т.е. в целом менять класс.Класс должен выполянть строго
   * ту роль, которая ему отведена. Но момент тонкий)
   *
 * - принцип открытости закрытости
 * этот принцип предполагает что классы д.б. закрыты для модификации но открыты для расширения
 * класс SaveComputer нарушает этот принцип. Для соблюдения можем использовать полиморфизм и абстрактные классы
 * Сделаем класс для разных методов.Добавляем новый функционал добавляя новые классы
 * и реализуя интерфейс с его методом. Короче не надо модифицировать классы, но добавляем новые классы или интерфейсы
 *
 *
 * * - принцип подстановки Барбары Лисков
*«функции, которые используют базовый тип, должны иметь
* возможность использовать подтипы базового типа не зная об этом».
* Подклассы должны заменять свои базовые классы. Есть два метода setData в классах Computer и OmenHP. И они разные. Дети, эт плохо.


*
* - принцип разделения интерфейсов
*
*«много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения».
* нужно больше интерфейсов Есть интерфейс Line и три класса Circle Line Rect.Это не удобно,
* потому что три метода надо переопределять, хотя используем только один.Дальше создаем другие интерфейсы ILine и IRect и
* ими расширяем классы. То есть один класс один интерфейс
*

* - принцип инверсии зависимости
*
*«Зависимость на Абстракциях. Нет зависимости на что-то конкретное».
* наши классы долдны зависить от абстракции.
*эти три класса нарушают принцип. поскольку завязаны напрямую с ModelForm
* То есть надо создать интерфейс
*
* */


